# *3. Произвести вычисления как в пункте 2, но с вычислением intercept.
# Учесть, что изменение коэффициентов должно производиться на каждом шаге одновременно
# (то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации


import numpy as np

x = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
y = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
# количество наблюдений
n = len(x)
alpha = 7e-5
b1 = 2.8
b0 = 400


def mse_(b0, b1, y, x, n):
    return np.sum((b0 + b1 * x - y) ** 2) / n


for i in range(70000):
    y0 = b0 + b1 * x
    b0 -= alpha * (2 / n) * np.sum((y0 - y))
    b1 -= alpha * (2 / n) * np.sum((y0 - y) * x)
    if (i%10000==0):
        print(f'It: {i}, b0={b0}, b1={b1},mse={mse_(b0, b1, y, x, n)}')

"""
IIt: 0, b0=400.0036372, b1=3.0810107999999996,mse=7217.739041378785
It: 10000, b0=413.2068723855817, b1=2.8484953443901238,mse=6713.722210977328
It: 20000, b0=422.4642367854159, b1=2.7803570494914314,mse=6590.006959226814
It: 30000, b0=428.9544893430972, b1=2.732585921161408,mse=6529.197419163444
It: 40000, b0=433.50474538176303, b1=2.6990940249330695,mse=6499.307812907173
It: 50000, b0=436.69488780433056, b1=2.675613166259987,mse=6484.616227323319
It: 60000, b0=438.93146715058595, b1=2.6591509534230178,mse=6477.394898105506
"""

"""
согласно ручному подсчету: 
коэффициент регрессии a:  444.1773573243596
коэффициент регрессии b:  2.620538882402765
"""